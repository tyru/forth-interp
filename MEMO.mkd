
TODO
============================

* word.c
  * 引数の処理などがワードの定義に混じるのはよくないと思うので事前に引数として渡されるようにする
  * popする個数を指定して、それを配列に保存する関数

* 一つの行ぴったりのメモリを確保する

* word\_defはSTLのpairみたいに管理する(2個の配列)

* tok\_strがNULLでないなら、表示する数値としてそれを使う。


追加テスト
============================

* APIがinterpのポインタ先かポインタ自体を書き換えてないか確認
* ストレステスト
* 文字列のパース

* OK()が無限ループを検出するようにする
  * forkして実行すれば可能 (並列化)
* is()
* dies\_ok() (並列化すれば可能)


やりたいこと
============================

* STL in C
* NSTL (Non Standard Temporary Library)
* void\*で値を渡し、遅いけど再実装することなくそれぞれのアルゴリズムを実装可能
  * queue
  * map

* Cにはデストラクタがないので、デストラクトを予定しておけるような機構が必要
* そこでqueueですよ
  * 何個か選んで実行
  * atexit()に登録可能
  * etc.


気付いたこと
=============================

* memset()は遅い。
* 関数の先でエラーが起こった場合、戻らない関数は\_noret、
  第一引数()に破壊的な変更を加える関数は\_dest、
  など最後に特性を付けるとソースが分かり易くなる。
  ただ、複数の特性を付けるとなると、普通の関数名との区切りが分からないので、
  特性はスネークケース、関数名はJava風に、などと分ける。
* ソース中のトークン(token\_type)と、保存するタイプ(word\_type)を分けるのはいいと思った。
* キャストにそれぞれマクロ名を付けるのはいいと思った。
* エラーハンドリングは構造体の中にerrnoのような変数を用意しておいた方が楽。
  * 返り値でエラーを知らせるのは、余程単純な関数以外は控えた方がいい。
  * またerrnoはマクロである可能性があるので、メンバや変数名や、至る所にそのような名前は使わないこと。


あるある
=============================

* 関数先のmalloc()で、そこに返すはずのポインタを上書きしてしまう
  * (なぜか値が入っていない or ゴミが入っている) and メモリリークエラー
